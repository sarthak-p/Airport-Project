# Results 

Over the course of the final project we learned a lot about graph implementations, real-world applications of data, project management, and industry algorithms. With flying recently becoming a normal, safe way to travel again, we thought it would be interesting to use airport, airlines, and route data from OpenFlights.org to implement some of the algorithms that we learned in class to investigate the shortest path between two given airports and identify the connectedness of a given airport. In order to do so, our project, a global flight simulator, consisted of four main deliverables: a directed graph from the acquired data, an implementation of the Depth-First Search Traversal, an implementation of Dijkstra’s Algorithm, and an implementation of the Normalized Degree Centrality Algorithm. 

 Our first deliverable was constructing a directed graph from the airport, airline, and route datasets we found on OpenFlights.org. The nodes of our graph were the airports, while the edges symbolized the specific routes that airplanes could fly. During the process of making our graph, we also realized that it would have to be weighted in order to calculate and compare distances between the airports for our shortest path algorithm. One of the main difficulties was reading the datasets in the first place, but we were able to get our readFromFile.cpp to open routes.dat and airports.dat successfully, and give an error if not. 
The first algorithm we implemented was a Depth-First Search (DFS), which we used to traverse the airport-route graph we created and provide users with a unique plan of airports to visit. Users input a source and destination, and the program will output a series of airports that connect them. The result is useful as it provides users with a trip plan likely different from the shortest route but possibly more interesting.

Our second deliverable was an implementation of Dijkstra’s Algorithm to find the shortest path/distance between two airports. The user would be prompted to input the IATA codes of the airport they wanted to depart from and the one they wanted to arrive at, then the output would be the shortest path in flights/airports and miles that they would have to travel, printed directly to the terminal. The main issue we ran into was that we were also having difficulties creating our graph, so it was not finished yet when we were writing Dijkstra. Therefore, we discovered that we could use an adjacency matrix instead to plot the distances from each flight. Then, we could go through the matrix and get the value of the distance to the next airport. In order to get the distance between two airports, we used their coordinates. Another issue we ran into was a non existing route between airports would print out the path through the whole matrix. In order to fix this we were able to use a simple if statement to exit the code if this distance is printed and to state that there is no path between the inputted airports.

Our final deliverable was an implementation of the normalized degree centrality algorithm to determine the connectedness of a given airport. Users can input a desired airport IATA code and receive a score ranking how well connected it is to other airports. This is useful for trip planning as it gives users a better understanding of the best airports to travel to and from. We originally intended on using Betweenness Centrality but ultimately decided that normalized degree centrality would be more intuitive for users. 

Initially, we divided up DFS and Dijkstra into teams of two then planned to all work on normalized degree centrality together at the end. However, not only did we discover that the algorithm was very complex, but we also realized it was inefficient for all four of us to be writing one algorithm at the same time. 

We encountered several challenges over the course of the final project that caused difficulties. In terms of non-technical issues, we had busy schedules that often limited how much time we could work on specific aspects of the project. DFS and Dijkstra’s Algorithm were both delayed until after the informal group deadlines which we set at the beginning. Although some aspects were delayed, we ultimately were able to accomplish all of the goals that we set. 

Additionally, parsing and processing the data was something unfamiliar to us and resulted in more planning and research than anticipated. For future projects we would ideally research more prior to beginning. This would allow everyone in the group to gain a better understanding of how much time is needed to be invested in each component of the project. Determining this upfront would have reduced the number of delays and allowed for better project organization.
Another issue we encountered was dealing with git errors and collaborating on a project using VCS. Ensuring merge conflicts are properly resolved and preventing the loss of code was a new challenge to most of us. In the future, using branches to properly work on features independently would have likely resolved many of our issues. 

That being said, we have come away with a much more robust understanding of how to work on collaborative projects, a skill that can directly translate into industry. Overall, our team is very proud of the work we have done and the project we created. Please refer to the below demo video link contains a complete run of all our coded algorithms and proof that they are working as intended. 

https://youtu.be/0FIJP5yoOXI

Please refer to the README and other deliverables submitted along with this project where we provide more information about our project. 
